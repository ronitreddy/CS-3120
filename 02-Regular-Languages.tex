\documentclass[12pt]{article}
\usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in,centering]{geometry}
\usepackage{fancyhdr}
\usepackage{epsfig}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{palatino}
\usepackage{wrapfig}
\usepackage{lastpage}
\usepackage{color}
\usepackage{ifthen}
\usepackage[table]{xcolor}
\usepackage{graphicx,type1cm,eso-pic,color}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{amsfonts}
\usepackage{tikz}
\usetikzlibrary{automata, positioning}

\def\course{CS 3120: Discrete Math and Theory II}
\def\homework{Regular Languages}
\def\semester{Fall 2024}

\newboolean{solution}
\setboolean{solution}{false}

% add watermark if it's a solution exam
% see http://jeanmartina.blogspot.com/2008/07/latex-goodie-how-to-watermark-things-in.html
\makeatletter
\AddToShipoutPicture{%
\setlength{\@tempdimb}{.5\paperwidth}%
\setlength{\@tempdimc}{.5\paperheight}%
\setlength{\unitlength}{1pt}%
\put(\strip@pt\@tempdimb,\strip@pt\@tempdimc){%
\ifthenelse{\boolean{solution}}{
\makebox(0,0){\rotatebox{45}{\textcolor[gray]{0.95}%
{\fontsize{5cm}{3cm}\selectfont{\textsf{Solution}}}}}%
}{}
}}
\makeatother

\pagestyle{fancy}

\fancyhf{}
\lhead{\course}
\chead{Page \thepage\ of \pageref{LastPage}}
\rhead{\semester}
%\cfoot{\Large (the bubble footer is automatically inserted into this space)}

\setlength{\headheight}{14.5pt}

\newenvironment{itemlist}{
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{itemize}}

\newenvironment{numlist}{
\begin{enumerate}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{enumerate}}

\newcounter{pagenum}
\setcounter{pagenum}{1}
\newcommand{\pageheader}[1]{
\clearpage\vspace*{-0.4in}\noindent{\large\bf{Page \arabic{pagenum}: {#1}}}
\addtocounter{pagenum}{1}
\cfoot{}
}

\newcounter{quesnum}
\setcounter{quesnum}{1}
\newcommand{\question}[2][??]{
\begin{list}{\labelitemi}{\leftmargin=2em}
\item [\arabic{quesnum}.] {} {#2}
\end{list}
\addtocounter{quesnum}{1}
}


\definecolor{red}{rgb}{1.0,0.0,0.0}
\newcommand{\answer}[2][??]{
\ifthenelse{\boolean{solution}}{
\color{red} #2 \color{black}}
{\vspace*{#1}}
}

\definecolor{blue}{rgb}{0.0,0.0,1.0}

\begin{document}

\section*{\homework}

\question[3]{
Draw out \emph{DFA}s (not \emph{NFA}s) for each of the following languages. For some of these, a small hint is provided. Your goal is to construct a \emph{DFA} with as few states as possible (just like how we prefer to write succinct code when possible). For all of these, let $\Sigma = \{a,b\}$
}

\begin{itemize}
	\item $\{w \ | \ w \text{ does not contain the substring } abba \}$ (\emph{*Hint: Draw out the DFA for a simpler language that DOES contain abba and then try to change that machine slightly.})

\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
  % Nodes
  \node[state, initial, accepting] (q0) {q0};
  \node[state, accepting] (q1) [right=of q0] {q1};
  \node[state, accepting] (q2) [right=of q1] {q2};
  \node[state, accepting] (q3) [right=of q2] {q3};
  \node[state] (q4) [below=2cm of q2] {q4};
  % Edges
  \path[->]
    (q0) edge [bend left] node {a} (q1)
         edge [loop above] node {b} ()
    (q1) edge [loop above] node {a} ()
         edge [bend left] node {b} (q2)
    (q2) edge [bend left] node {a} (q1)
         edge [bend left] node {b} (q3)
    (q3) edge [bend right] node [below] {a} (q4)
         edge [bend left] node {b} (q0)
    (q4) edge [loop right] node {a,b} ();
\end{tikzpicture}

	\item $\{w \ | \ w \text{ contains BOTH the substrings ab and ba}\}$

\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
  % Nodes
  \node[state, initial] (q0) {q0};  % Initial state: neither "ab" nor "ba" seen
  \node[state] (q1) [right of=q0] {q1}; % "a" seen, waiting for "ab"
  \node[state] (q2) [right of=q1] {q2}; % "ab" seen
  \node[state] (q3) [below of=q1] {q3}; % "b" seen, waiting for "ba"
  \node[state] (q4) [below of=q2] {q4}; % "ba" seen
  \node[state, accepting] (q5) [right of=q4] {q5}; % Both "ab" and "ba" seen

  % Transitions
  \path[->]
    (q0) edge [bend left] node {a} (q1)   % Seeing 'a' moves from q0 to q1
         edge [loop above] node {b} ()    % Seeing 'b' keeps it in q0
    (q1) edge [bend left] node {b} (q2)   % Seeing 'b' forms "ab", go to q2
         edge [loop above] node {a} ()    % Seeing 'a' keeps it in q1
    (q2) edge [bend left] node {a} (q1)   % Seeing 'a' moves back to q1
         edge [bend left] node {b} (q5)  % Seeing 'b' completes "ba", go to accepting state
    (q0) edge [bend right] node {b} (q3)  % Seeing 'b' moves from q0 to q3 (start of "ba")
    (q3) edge [bend right] node {a} (q4)  % Seeing 'a' forms "ba", go to q4
         edge [loop below] node {b} ()    % Seeing 'b' keeps it in q3
    (q4) edge [bend left] node {b} (q5)  % Seeing 'b' completes "ab", go to accepting state
         edge [bend right] node {a} (q1);  % Seeing 'a' keeps searching for "ab"
\end{tikzpicture}

	\item $\{w \ | \ w \in a^*b^*a^* \}$

\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]

  % States
  \node[state, initial, accepting] (q0) {$q_0$};  % Initial and accepting state
  \node[state, accepting] (q1) [right of=q0] {$q_1$}; % State for reading b's
  \node[state, accepting] (q2) [right of=q1] {$q_2$}; % State for reading a's after b's
  \node[state] (q3) [below of=q1] {$q_3$};  % Fixed label for q3

  % Transitions
  \path[->]
    (q0) edge [loop above] node {a} ()          % q0 loops on 'a'
         edge [bend left] node {b} (q1)         % q0 goes to q1 on 'b'
    (q1) edge [loop above] node {b} ()          % q1 loops on 'b'
         edge [bend left] node {a} (q2)         % q1 goes to q2 on 'a'
    (q2) edge [loop above] node {a} ()          % q2 loops on 'a'
         edge [bend right] node {b} (q3)      % q2 goes to trap on 'b'
    (q3) edge [loop above] node {a,b} ();     % trap loops on both 'a' and 'b'

\end{tikzpicture}

	\item $\{w \ | \ w \neq ab \wedge w \neq bb \}$

\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
    \node[state,initial] (q0) {$q_0$};
    \node[state] (q1) [above right of=q0] {$q_1$};
    \node[state] (q2) [below right of=q0] {$q_2$};
    \node[state,accepting] (qaccept) [right of=q2] {$q_{\text{accept}}$};
    \node[state] (qreject) [right of=q1] {$q_{\text{reject}}$};

    \path
    (q0) edge node[above left] {a} (q1)
         edge node[below left] {b} (q2)
    (q1) edge[loop above] node {a} (q1)
         edge node[above] {b} (qreject)
    (q2) edge node[below] {a} (qaccept)
         edge node[above right] {b} (qreject)
    (qaccept) edge[loop right] node {a,b} (qaccept)
    (qreject) edge[loop right] node {a,b} (qreject);
\end{tikzpicture}

	\item $\{w \ | \ w \in a^iw' \ | \ i \in \mathbb{N}, w' \in \{a,b\}^*, \text{w' contains at least i a's} $ (\emph{*Hint: This one LOOKS not regular but it actually is. Can you figure out why?})

\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

\node[state,initial] (q0) {$q_0$};
\node[state, right of=q0] (q1) {$q_1$};
\node[state, right of=q1] (q2) {$q_2$};
\node[state, right of=q2] (q3) {$q_3$};
\node[state, right of=q3] (q4) {$q_4$};
\node[state,accepting, right of=q4] (q5) {$q_5$};
\node[state, below of=q2] (qreject) {$q_\text{reject}$};

\path
    (q0) edge node[above] {a} (q1)
    (q1) edge node[above] {a} (q2)
    (q2) edge node[above] {a} (q3)
    (q2) edge[bend left] node[left] {b} (q3)
    (q3) edge node[above] {a} (q4)
    (q3) edge[loop above] node {b} ()
    (q4) edge node[above] {a} (q5)
    (q4) edge[loop above] node {b} ()
    (q5) edge[loop above] node {a,b} ()
    (q0) edge node[below left] {b} (qreject)
    (q1) edge[bend right] node[below] {b} (qreject)
    (qreject) edge[loop right] node {a,b} ();
\end{tikzpicture}

\end{itemize}

\vspace{12pt}

\question[3]{
Prove that regular languages are closed under \emph{intersection}. Do this by starting with \emph{DFA}s for two regular languages $A$ and $B$, and describe how to construct a new \emph{DFA} for $A \cap B$\
\\

We start with two regular languages A and B, whose DFA's can be represented as $M_A = (Q_A, \Sigma, \delta_A, q_{A0}, F_A)$ and $M_B = (Q_B, \Sigma, \delta_B, q_{B0}, F_B)$. To construct a new DFA for $A \cap B$, say $M_C = (Q_A $ x $ Q_B, \Sigma, (\delta_A(q_A,a),\delta_A(q_A,a)) ,F_A $ x $ F_B)$, such that we would need to take the cross product and get all pairs of states and a transition function that simulates transitions for both DFAs $M_A $ and $ M_B$.\\
\\
Let w be any string in $\Sigma*$, we need to show that w $\in$ a language, $C$, accepted by $M_C$. If w exists in the set $A \cap B$, then it must reach accepting states in both A and B, such that $q_A \in F_A$ and $q_B \in F_B$ where $F_C$ will reach a state $(q_A, q_B)$. The string $w$ will be apart of the language $C$ by construction of the DFA for $C$ as it will only accept strings to be part of the language if it is in languages $A$ and $B$.
}

%\delta((q_{A0}, q_{B0}), a) = 

\vspace{12pt}

\question[3]{
Prove that regular languages are closed under \emph{complement}. Do this by starting with a \emph{DFA} for a regular language $A$, and describe how to construct a new \emph{DFA} for $\bar{A}$.
\\

Let $M = (Q_A, \Sigma, \delta, q_0, F_A)$ be a DFA for the regular language $A$, where $Q_A$ is the set of states, $\Sigma$ is the alphabet, $\delta$ is the transition function, $q_0$ is the start state, and $F_A$ is the set of accepting states.\\
\\
To construct a DFA for the complement of $A$, denoted $\bar{A}$, we define a new DFA $M' = (Q_A, \Sigma, \delta, q_0, Q_A \setminus F_A)$. In this new DFA, the set of accepting states is $Q_A \setminus F_A$, meaning all states in $Q_A$ that were not accepting in $A$ are now accepting in $M'$.\\
\\
For any string $w$, if $w$ is in the language $A$, it is accepted by $M$, meaning the state reached after processing $w$ is in $F_A$. However, in $M'$, this same string $w$ will be rejected, as $w$ leads to a state that is not in the accepting set of $M'$. Conversely, if $w$ is not in $A$, it will be accepted by $M'$. This construction proves that the complement of a regular language is also regular.
}

\vspace{12pt}

\question[3]{
For any string $w = w_1w_2,...,w_n$, let $w^R$ be the reverse of string $w$ (i.e., $w^R=w_n,...,w_2,w_1$). Prove that if a language $A$ is regular, then the language $A^R = \{w^R \ | \ w \in A\}$ is also regular.


}


\textbf{1. Given:} $A$ is a regular language and that means there exists a DFA $M = (Q, \Sigma, \delta, q_0, F)$ that recognizes $A$.

\section*{2. Construction of \( M^R \)}

To construct an NFA \( M^R \) that recognizes \( A^R \):

\[
M^R = (Q, \Sigma, \delta^R, F, \{q_0\}),
\]
where:
\begin{itemize}
    \item \( Q \) and \( \Sigma \) remain the same as in the original NFA \( M \),
    \item The transition function \( \delta^R(q, a) = \{p \mid \delta(p, a) = q\} \), which reverses the transitions in \( M \),
    \item The set of initial states in \( M^R \) is the set of accepting states of \( M \),
    \item The only accepting state in \( M^R \) is \( \{q_0\} \), which was the initial state of \( M \).
\end{itemize}

By reversing all transitions in \( M \), we create \( M^R \), which accepts the reverse of any string accepted by \( M \).

\section*{3. Proof of correctness}

\begin{itemize}
    \item[(a)] Suppose \( w = w_1 w_2 \ldots w_n \in A \). In the NFA \( M \), there must exist a sequence of states \( r_0, r_1, \ldots, r_n \) such that:
    \begin{itemize}
        \item \( r_0 = q_0 \),
        \item \( r_i = \delta(r_{i-1}, w_i) \) for \( 1 \leq i \leq n \),
        \item \( r_n \in F \), meaning \( w \) is accepted by \( M \).
    \end{itemize}
    
    \item[(b)] Similarly, \( w^R = w_n \ldots w_2 w_1 \). In the reversed NFA \( M^R \), there will be a sequence of states \( s_n, s_{n-1}, \ldots, s_0 \) such that:
    \begin{itemize}
        \item \( s_n \in F \) (since the accepting states of \( M \) become the initial states in \( M^R \)),
        \item \( s_{i-1} \in \delta^R(s_i, w_i) \) for \( n \geq i \geq 1 \) (by the construction of \( \delta^R \)),
        \item \( s_0 = q_0 \), meaning \( w^R \) is accepted by \( M^R \).
    \end{itemize}
    
    \item[(c)] This shows that if \( w \in A \), then \( w^R \in L(M^R) \), the language accepted by \( M^R \).
    
    \item[(d)] Conversely, if \( w^R \in L(M^R) \), we can reverse the argument to show that \( w \in A \).
\end{itemize}

Thus, \( L(M^R) = A^R \).

\section*{5. Conversion of NFA to DFA}

While \( M^R \) is an NFA, there exists an equivalent DFA.  \( M'_R \) represents the DFA obtained from \( M^R \). Since \( L(M'_R) = L(M^R) = A^R \), this shows that \( A^R \) can also be recognized by a DFA.

\section*{6. Conclusion}

By constructing the DFA \( M'_R \) that recognizes \( A^R \), we have demonstrated that \( A^R \) is a regular language. Therefore, if \( A \) is regular, so is \( A^R \).

\vspace{12pt}

\question[3]{
Use the pumping lemma to show that the following languages are not regular OR argue that they are regular. 
}

\begin{itemize}
	\item $A= \{ 0^*0^n1^n1^* \ | \ n \geq 0\}$\\
\\
Assume that language $A$ is regular.\\
\\
By the pumping lemma, there exists a pumping length $p$ such that any string $s$ in the language $A$ of length at least $p$ can be divided into three parts $s = xyz$ satisfying the following conditions:
\begin{itemize}
    \item for each $i \geq 0, xy^iz \in A$,
    \item $|y| > 0$,
    \item $|xy| \leq p$.
\end{itemize}

In this case, let us select the string $s' = 0^p1^p$, which follows the form required by language $A$ and is structured such that we have $p$ zeros followed by $p$ ones.\\

According to the pumping lemma, $s'$ can be divided into $s' = xyz$, where we can "pump" $y$ any number of times, $|y| > 0$, and $|xy| \leq p$. Based on this, there are three potential cases to consider:

\begin{itemize}
    \item $y$ contains only 0s: If $y$ consists only of 0s from the first block of $0^p$, pumping $y$ will increase or decrease the number of 0s in this block. The resulting string, then, would look like $0^{p+k}1^p$, where $k$ is the number of 0s added or removed, which breaks the balance between the number of 0s and 1s, thereby contradicting the structure of the language.
    
    \item $y$ contains some 0s and some 1s: If $y$ contains both 0s and 1s, pumping $y$ will mix the 0s and 1s, disrupting the boundary between the block of 0s and the block of 1s. The resulting string would look like $0^{p-k}1^{p+k}$, which is not of the form $0^n1^n$, thereby contradicting the structure of the language.
    
    \item $y$ contains only 1s: If $y$ consists only of 1s from the second block of $1^p$, pumping $y$ will increase or decrease the number of 1s in this block. The resulting string, then, would look like $0^p1^{p+k}$, where $k$ is the number of 1s added or removed, which breaks the balance between the number of 0s and 1s, thereby contradicting the structure of the language.
\end{itemize}

In all three cases, pumping $y$ results in a string that violates the structure of the language $A$. Whether $y$ contains only 0s, both 0s and 1s, or only 1s, the resulting string after pumping does not preserve the required balance between the blocks of 0s and 1s. As such, we have found a valid string $s'$ that cannot be pumped without breaking the conditions of the language. Thus, this contradicts the assumption that $A$ is regular, and we can conclude that language $A$ is not regular.

	\item $B= \{ www \ | \ w \in \{0,1\}^* \}$\\
\\
Assume that language $B$ is regular.\\

By the pumping lemma, there exists a pumping length $p$ such that any string $s$ in the language $B$ of length at least $p$ can be divided into three parts $s = xyz$ satisfying the following conditions:
\begin{itemize}
    \item for each $i \geq 0, xy^iz \in B$,
    \item $|y| > 0$,
    \item $|xy| \leq p$.
\end{itemize}

In this case, let us select the string $s' = 0^p10^p10^p$, which consists of three consecutive copies of the substring $0^p$ with $1$ separating each substring instance (and consequently follows the form $www$ required by the language $B$), making it a valid string in $B$.\\

According to the pumping lemma, $s'$ can be divided into $s' = xyz$, where we can "pump" $y$ any number of times, $|y| > 0$, and $|xy| \leq p$. Based on this, there are three potential cases to consider:

\begin{itemize}
    \item $y$ contains only 0s: If $y$ consists only of 0s from the first block of $0^p$, pumping $y$ will increase or decrease the number of 0s in this block. The resulting string, then, would look like $0^{p+k}10^p10^p$, where $k$ is the number of 0s added or removed. This string is no longer of the form $www$, as the first part is no longer the same as the subsequent parts, thereby contradicting the structure of the language.
    
    \item $y$ contains a 1 and some 0s: If $y$ contains a 1 and some 0s, spanning across the boundary between the second block of $0^p$ and the first 1, pumping $y$ will mix 0s and the 1, resulting in a string like $0^{p-k}110^p10^p$. This string disrupts the pattern $www$ because the middle copy of $w$ no longer starts with the same 0s, thereby violating the required repetition of $w$.
    
    \item $y$ contains some 0s and a 1: If $y$ consists of some 0s and the 1 from the second block of $0^p$, pumping $y$ will change the structure of the second occurrence of $w$. The resulting string would look like $0^p1^k0^{p-k}10^p$, which again does not maintain the required repetition of $w$, leading to a contradiction.
\end{itemize}

In all three cases, pumping $y$ results in a string that violates the structure of the language $B$. Whether $y$ contains only 0s, a 1 and some 0s, or some 0s and a 1, the resulting string after pumping does not maintain the repetition required by the language $B$. As such, we have found a valid string $s'$ that cannot be pumped without breaking the conditions of the language. Thus, this contradicts the assumption that $B$ is regular, and we can conclude that language $B$ is not regular.
\end{itemize}

\vspace{12pt}

\question[3]{
Find and describe the error that exists in the following proof. The proof attempts to show that $0^*1^*$ is not regular, when in fact it is:
\\
\\
\emph{
Assume, for sake of contradiction, that $0^*1^*$ is regular. We select an element from this language that is greater than the pumping length $p$. We select $0^p1^p$. In class, when proving that $0^n1^n$ was not regular, we showed that $0^p1^p$ cannot be pumped. Therefore, $0^*1^*$ is not regular.
}
\\
\\
The error in the proof lies in a misunderstanding of the language $0^*1^*$ and a misapplication of the pumping lemma in an attempt to show that $0^*1^*$ is not regular. For context, the pumping lemma for regular languages states that for any regular language $A$, there exists a pumping length $p$ such that any string $s \in A$ where $|s| \geq p$ can be divided into three parts $s = xyz$ satisfying the following conditions:
\begin{itemize}
    \item for each $i \geq 0, xy^iz \in A$,
    \item $|y| > 0$,
    \item $|xy| \leq p$.
\end{itemize}

In this case, the proof incorrectly references this concept to select the string $s' = 0^p1^p$ from the language $0^*1^*$ and assumes that this string cannot be pumped, following the reasoning outlined in class to prove that $0^n1^n$ is not regular. However, $0^*1^*$ is a different language with a simpler structure than $0^n1^n$, allowing any number of $0$s followed by any number of $1$s as opposed to requiring the number of $0$s to exactly match the number of $1$s; accordingly, the string $0^p1^p$ can indeed be pumped within this language.\\
\\
For example, if we divide $s'$ such that $s' = xyz$ and select $y$ to be a section of $s'$ containing only $0$s (e.g., $y = 0^k$ for some $k > 0$), we will always be able to pump $y$ by repeating or omitting occurrences of $0$s (i.e., consider strings $0^{p+k}1^p$ or $0^{p-k}1^p$), and the resulting strings will still belong to $0^*1^*$. Similarly, if we select $y$ to be a section of $s'$ containing only $1$s (e.g., $y = 1^k$ for some $k > 0$), we will always be able to pump $y$ by repeating or omitting occurrences of $1$s (i.e., consider strings $0^p1^{p+k}$ or $0^p1^{p-k}$); through this logic, we see that the selected string $s' = 0^p1^p$ can be pumped and will still fit within the structure of the language. Furthermore, pumping $y$ in any case still produces a valid string in $0^*1^*$, as it merely changes the number of $0$s and/or the number of $1$s while retaining the structure of some number of $0$s followed by some number of $1$s, which is allowed by the language.\\
\\
Conclusively, the root issue in the proof is the incorrect assumption that the language $0^*1^*$ behaves like the language $0^n1^n$, where the number of $0$s must match the number of $1$s. Instead, with $0^*1^*$, there is no such restriction on the relationship between the number of $0$s and the number of $1$s, meaning that the pumping lemma can be applied without generating strings that fall outside the language. Thus, the proof fails in its attempt to employ similar rationale showing that the language $0^n1^n$ is not regular to show that the language $0^*1^*$ is also not regular, when, in fact, it is regular.
}

\vspace{12pt}


\end{document}
